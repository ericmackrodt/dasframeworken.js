// Generated by dts-bundle v0.7.2

declare module '*.html' {
    var value: Frameworken.IComponent;
    export default value;
}
namespace Frameworken {
    interface IComponent {
        controller: any;
        render: (controller: any, container: any) => Element;
        selector: string;
    }
    interface IRoute {
        path: string;
        root: IComponent;
        resolve?: <T>(route: IRoute) => Promise<T> | boolean | void;
    }
    interface IModuleOptions {
        preLoad?: <T>() => Promise<T> | boolean | void;
        types?: any[];
        routes?: IRoute[];
        components: Object[];
        rootComponent: IComponent;
    }
    interface IModule {
        getComponent: (selector: string) => IComponent;
        deploy: (element: HTMLElement) => void;
    }
    interface IFrameworken {
        module: (name: string, options: IModuleOptions) => IModule;
    }
}

export class ComponentContainer {
    readonly controller: IController;
    constructor(_container: Container, _module: Frameworken.IModule, _component: Frameworken.IComponent);
    registerEvent(element: Element, event: string, callback: (arg: any) => void): void;
    initialize(element: Element): Element;
    registerBinding(property: string, binding: (property: string) => void): void;
    setInwardBinding(element: HTMLInputElement, controllerProperty: string): void;
    setEvent(element: Element, event: string, callback: (controller: IController, $event: Event) => any): void;
    instantiateChildComponent(name: string, parent: Element): Element;
    instantiateIfDirective(condition: string, parent: Element, contextFn: () => Element): boolean;
    instantiateForDirective(propertyFn: () => any, propertyName: string, parent: Element, contextFn: (item: any) => Element): void;
    teardown(): void;
}

export const setupController: (controllerType: Function) => void;

export const module: (name: string, options: Frameworken.IModuleOptions) => Frameworken.IModule;

/**
    * Represents the container
    */
export class Container {
        readonly typeRegistry: ITypeRegistry;
        constructor();
        /**
            * Instantiates a type that is registered in the container with its dependencies.
            * @param type Type that will be instantiated, it can be the type itself or the name.
            */
        getInstance<T>(type: Type<T> | string): any;
        /**
            * Instantiates any type and tries to resolve dependencies that are registered in the container.
            * @param type The type to be resolved
            */
        resolve<T>(type: Type<T>): T;
        /**
            * Registers a type in the container.
            * @param type Type to be registered
            */
        registerType<T>(type: Type<T>): void;
}

export class ForDirective {
    static readonly metadata: {
        selector: string;
    };
    constructor(_parent: Element, _evtAggregator: Pubsub, _context: (item: any) => Element, _collectionFn: () => any);
    setup(field: string): void;
    teardown(): void;
}

export class IfDirective implements IDirective {
    static readonly metadata: {
        selector: string;
    };
    constructor(_parent: Element, _controller: IController, _evtAggregator: Pubsub, _context: () => Element);
    setup(value: string): void;
    teardown(): void;
}

export class Pubsub {
    constructor();
    subscribe(name: string, callback: Function): void;
    emit(name: string, data: any): void;
    get(name: string): any;
    unsubscribe(name: string): void;
    teardown(): void;
}

export class Subscriber {
    constructor();
    subscribe(fn: Function): void;
    emit(data: any): void;
    remove(fn: Function): void;
    teardown(): void;
}

export class Module {
    readonly rootComponent: Frameworken.IComponent;
    constructor(_container: Container, _name: string, options: Partial<Frameworken.IModuleOptions>);
    _registerRoutes(routes: Frameworken.IRoute[]): void;
    _registerComponents(components: any[]): void;
    _buildComponent(type: Frameworken.IComponent, element: Element): ComponentContainer;
    getComponent(name: string): Frameworken.IComponent;
    deploy(element: HTMLElement): void;
}

export class Router {
    onRouteChanging: (oldRoute: Frameworken.IRoute, newRoute: Frameworken.IRoute) => void;
    onRouteChanged: (currentRoute: Frameworken.IRoute) => void;
    constructor(routes: Frameworken.IRoute[]);
    _getHash(url: string): string;
    destroy(): void;
}

export interface IController extends Object {
    [key: string]: any;
    onPropertyChanged?: (name: string) => void;
}
export interface ITypeMetadata {
    selector?: string;
    dependencies?: Function[];
}
export interface Type<TType> extends Function {
    name: string;
    metadata?: ITypeMetadata;
    dependencies?: Type<Object>[];
    new (...args: any[]): TType;
}
export interface IEventListener {
    element: Element;
    event: string;
    callback: (arg: Event) => void;
}
export interface IDirective {
    setup: (value: string) => void;
    teardown: () => void;
}
export interface IRegisteredType {
    type: Type<any>;
    instance: any;
}
export interface ITypeRegistry {
    [key: string]: IRegisteredType;
}

/**
    * Returns a promise based on the object passed as parameter.
    * It returns a failed or successful promise if it's a boolean.
    * If it's a promise, it returns itself.
    * If it's some other object, it returns a succesfull promise with that obj.
    * @param obj Object to promise
    */
export const returnPromise: (obj: any) => any;
/**
    * Instantiates a Type.
    * @param type Type to be instantiated.
    * @param params Parameters to be passed to the constructor.
    */
export const instantiateType: <T>(type: Type<T>, ...params: any[]) => T;
/**
    * Calls a function given the context if it's valid.
    * @param fn Function to be called.
    * @param ctx "This" context in which the function will be called.
    * @param args The arguments for the function.
    */
export const call: (fn: Function, ctx: Function, ...args: any[]) => any;
/**
    * Checks object is a function.
    * @param fn Function to verify
    */
export const isFunction: (fn: any) => boolean;

